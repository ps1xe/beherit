import pickle
import numpy
from music21 import instrument, note, stream, chord, duration
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import LSTM
from keras.layers import BatchNormalization as BatchNorm
from keras.layers import Activation
import boto3
import uuid
import os
from dotenv import load_dotenv
import sys

load_dotenv()
#----------------------------------------------------------------------------------------------------------------------
#готовит данные для генератора
def prepare_sequences(notes, pitchnames, n_vocab):

    #создает словарь, который сопоставляет каждой ноте или аккорду число
    note_to_int = dict((note, number) for number, note in enumerate(pitchnames))

    #длина последовательности(количество нот)
    sequence_length = 100

    #входные данные 
    network_input = []

    for i in range(0, len(notes) - sequence_length, 1):
        #каждая входная последовательность содержит sequence_length нот, начиная с i-й ноты в списке notes
        sequence_in = notes[i:i + sequence_length]

        #входная последовательность преобразуется в список целых чисел, используя словарь note_to_int и добавляется в список network_input
        network_input.append([note_to_int[char] for char in sequence_in])

    #количество последовательностей
    n_patterns = len(network_input)

    #network_input преобразуется в формат, совместимый с LSTM слоями, с помощью функции numpy.reshape()
    normalized_input = numpy.reshape(network_input, (n_patterns, sequence_length, 1))

    #входные данные нормализуются, разделив каждое значение на количество уникальных нот (n_vocab)
    normalized_input = normalized_input / float(n_vocab)

    return (network_input, normalized_input)

#----------------------------------------------------------------------------------------------------------------------
#создает lstm для генерации
def create_network(network_input, n_vocab, genre = 'rock'):
    model = Sequential()
    model.add(LSTM(
        512,
        input_shape=(network_input.shape[1], network_input.shape[2]),
        recurrent_dropout=0.3,
        return_sequences=True
    ))
    model.add(LSTM(512, return_sequences=True, recurrent_dropout=0.3))
    model.add(LSTM(512))
    model.add(BatchNorm())
    model.add(Dropout(0.3))
    model.add(Dense(256))
    model.add(Activation('relu'))
    model.add(BatchNorm())
    model.add(Dropout(0.3))
    model.add(Dense(n_vocab))
    model.add(Activation('softmax'))
    model.compile(loss='categorical_crossentropy', optimizer='rmsprop')

    if(genre == 'rock'):
        model.load_weights('src/algoritm/generated/weights/test/weights-08-4.6203-bigger.hdf5')
    else:
        model.load_weights('src/algoritm/generated/weights/test/weights-08-4.6203-bigger.hdf5')

    return model

#----------------------------------------------------------------------------------------------------------------------
#генерирует новую музыку используя обученную модель
def generate_notes(model, network_input, length, pitchnames, n_vocab):

    #случайное число для выбора последовательности
    start = numpy.random.randint(0, len(network_input)-1)

    #словарь нота - уникальное целое число
    int_to_note = dict((number, note) for number, note in enumerate(pitchnames))

    #входные данные для предсказания
    pattern = network_input[start]

    #выходные данные для предсказания
    prediction_output = []

    # Генерирует 500 нот
    for note_index in range(length):

        #prediction_input преобразуется в формат, совместимый с LSTM слоями, с помощью функции numpy.reshape()
        prediction_input = numpy.reshape(pattern, (1, len(pattern), 1))

        #prediction_input нормализуются, разделив каждое значение на количество уникальных нот (n_vocab)
        prediction_input = prediction_input / float(n_vocab)

        #предсказание следующей ноты для последовательности
        prediction = model.predict(prediction_input, verbose=0)
        
        #индификатор ноты в инт
        index = numpy.argmax(prediction)

        #сама нота или аккорд
        result = int_to_note[index]
    
        #ресультат
        prediction_output.append(result)

        #добавление ноты в патерн для предсказания
        pattern.append(index)

        #новая последовательность из старой, полученная добавлением новой ноты в конец и смещением на одну позицию
        pattern = pattern[1:len(pattern)]

    return prediction_output

#----------------------------------------------------------------------------------------------------------------------
#из списка нот(или аккордов) преобразует в midi
def create_midi(prediction_output):

    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # pattern is a chord
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
        # pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        offset += 0.5

    midi_stream = stream.Stream(output_notes)

    midi_stream.write('midi', fp='src/algoritm/generated/tmp/generated-output.mid')

    with open('src/algoritm/generated/tmp/generated-output.mid', 'rb') as f:
        return f.read()


 #----------------------------------------------------------------------------------------------------------------------
 # сохранение в s3  
def save_in_s3(buffer):

    access_key = str(os.environ.get('S3_ACCESS_KEY_ID'))
    secret_access_key = str(os.environ.get('S3_SECRET_ACCESS_KEY'))
    endpoint_url = str(os.environ.get('S3_ENDPOINT'))
    bucket = str(os.environ.get('S3_BUCKET_NAME_SOUNDS'))

    session = boto3.session.Session()
    s3 = session.client(
    aws_access_key_id=access_key,
    aws_secret_access_key=secret_access_key, 
    service_name='s3',
    endpoint_url= endpoint_url,
)
    
    key = str(uuid.uuid4()) + '.mid'
    s3.put_object(Bucket=bucket, Key=key, Body=buffer)

    print(key) 

#----------------------------------------------------------------------------------------------------------------------
#собираем все методы
def generate(genre, length = 500):
    with open('src/algoritm/generated/notes/test/notes', 'rb') as filepath:
        notes = pickle.load(filepath)

    pitchnames = sorted(set(item for item in notes))
    n_vocab = len(set(notes))

    network_input, normalized_input = prepare_sequences(notes, pitchnames, n_vocab)
    model = create_network(normalized_input, n_vocab, genre)
    prediction_output = generate_notes(model, network_input, length, pitchnames, n_vocab)
    midi = create_midi(prediction_output)
    return save_in_s3(midi)
    


if __name__ == '__main__':
    generate(sys.argv[1], int(sys.argv[2]))
